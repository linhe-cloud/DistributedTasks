# 分布式任务平台技术方案（Gin + Redis List + PostgreSQL + cron + Docker/Nginx/Supervisor）

## 1. 项目概述
- 目标：构建可水平扩展的分布式任务平台，支持即时任务与定时任务，具备高可用、可观测、可管控能力。
- 架构风格：轻量服务化，API 层与调度器分离，Worker 可水平扩展；Redis 作为队列与轻缓存；PostgreSQL 作为权威元数据存储。
- 关键能力：任务幂等与去重、重试与退避、租约与心跳（避免重复消费）、死信队列（DLQ）、优先级与多队列、监控与告警。

## 2. 目标与非目标
- 目标：
  - 即时/定时任务创建与执行、任务状态查询与管理。
  - Worker 并发执行、重试策略、DLQ 与人工重放。
  - 水平扩展与保活、基础安全与限流、可观测指标与日志。
- 非目标（当前阶段）：
  - 复杂编排（DAG/依赖图）、跨地域一致性、多租户强隔离（后续版本规划）。

## 3. 技术栈与版本
- 语言与框架：Go 1.25（Go Modules）+ Gin。
- 存储：PostgreSQL（任务与运行元数据）、Redis（List 队列 + 缓存）。
- 调度：cron（如 robfig/cron v3）。
- 部署：Docker 容器化 + Nginx 反向代理 + Supervisor 保活（Worker）。

## 4. 总体架构
- 组件：
  - API 服务（Gin）：任务创建、查询、管理，健康检查与指标。
  - 调度器（Scheduler）：定时扫描计划，生成运行实例并入队。
  - 队列（Redis List + ZSET）：ready 队列、delayed 重试队列、dlq 死信队列。
  - Worker 执行器：消费队列、执行任务、上报结果、续租与心跳。
  - 数据库（PostgreSQL）：任务、任务运行记录、调度计划、Worker 元数据。
  - 反向代理（Nginx）：统一入口、TLS、基础限流与安全。
  - 进程守护（Supervisor）：Worker 保活与自动拉起。
- 数据流：
  1) 即时任务：API 创建 → 写入 DB → 入队 Redis → Worker 执行 → 回写结果。
  2) 定时任务：Scheduler 扫描计划 → 生成运行实例 → 入队 Redis → Worker 执行 → 回写结果。
- 可用性：组件多副本部署；Redis 开启 AOF；PostgreSQL 主备或托管；失败补偿与重放。

## 5. 任务模型与状态机
- 任务类型：
  - 即时任务（Immediate）：创建后立即入队。
  - 定时任务（Scheduled）：由 cron 表达式或固定时间触发。
- 状态机：
  - 任务（Task）：PENDING → SCHEDULED/QUEUED → PARTIALLY_RUNNING（可选并发）→ COMPLETED/FAILED/CANCELLED。
  - 运行实例（TaskRun）：QUEUED → RUNNING → SUCCEEDED/FAILED/RETRYING/CANCELLED。
- 幂等：
  - dedup_key 全局唯一；API 入参强制携带；服务器端对 PENDING/QUEUED 做去重返回。

## 6. PostgreSQL 数据模型（DDL 建议）
```sql
-- 任务定义
CREATE TABLE tasks (
  id UUID PRIMARY KEY,
  name VARCHAR(255) NOT NULL,
  type VARCHAR(16) NOT NULL CHECK (type IN ('immediate', 'scheduled')),
  priority INT NOT NULL DEFAULT 0,
  queue_name VARCHAR(64) NOT NULL,
  payload JSONB NOT NULL,
  max_retries INT NOT NULL DEFAULT 3,
  retry_strategy JSONB NOT NULL,
  status VARCHAR(16) NOT NULL CHECK (status IN ('pending','scheduled','queued','completed','failed','cancelled')),
  dedup_key VARCHAR(255) UNIQUE,
  created_by VARCHAR(64),
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE INDEX idx_tasks_queue_status_pri ON tasks(queue_name, status, priority DESC);

-- 任务运行实例
CREATE TABLE task_runs (
  id UUID PRIMARY KEY,
  task_id UUID NOT NULL REFERENCES tasks(id),
  attempt INT NOT NULL,
  status VARCHAR(16) NOT NULL CHECK (status IN ('queued','running','succeeded','failed','retrying','cancelled')),
  worker_id VARCHAR(64),
  started_at TIMESTAMPTZ,
  finished_at TIMESTAMPTZ,
  result JSONB,
  next_retry_at TIMESTAMPTZ,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
CREATE UNIQUE INDEX idx_task_runs_task_attempt ON task_runs(task_id, attempt);

-- 定时计划
CREATE TABLE schedules (
  id UUID PRIMARY KEY,
  task_template_id UUID NOT NULL REFERENCES tasks(id),
  cron_expr VARCHAR(128) NOT NULL,
  timezone VARCHAR(64) NOT NULL DEFAULT 'UTC',
  enabled BOOLEAN NOT NULL DEFAULT TRUE,
  last_triggered_at TIMESTAMPTZ
);
CREATE INDEX idx_schedules_enabled ON schedules(enabled);

-- Worker 元数据
CREATE TABLE workers (
  id UUID PRIMARY KEY,
  name VARCHAR(128) NOT NULL,
  queues JSONB NOT NULL,           -- {"high":1, "normal":1}
  heartbeat_at TIMESTAMPTZ,
  status VARCHAR(16) NOT NULL CHECK (status IN ('online','offline','draining')),
  capacity INT NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);
```

## 7. Redis 队列与键设计
- 队列命名：
  - ready 队列（List）：`queue:{name}:ready`
  - 延时/重试（ZSET）：`queue:{name}:delayed`（score 为触发时间戳）
  - 死信队列（List）：`queue:{name}:dlq`
- 租约与心跳：
  - 租约键：`lease:{task_run_id}`，值为 Worker ID，设置 EXPIRE TTL；Worker 定期续租。
- 载荷格式（JSON）：
```json
{
  "task_run_id": "UUID",
  "task_id": "UUID",
  "attempt": 1,
  "payload": {"...": "..."},
  "priority": 10,
  "lease_ttl": 30
}
```
- 重试流程：失败任务移入 delayed（ZSET）；到期后由搬运器/Worker 线程将其回填到 ready（List）。
- 并发与优先级：按 high/normal/low 多队列；Worker 轮询或按权重消费。

## 8. API 设计（Gin 路由与契约）
- 任务管理
  - POST /api/v1/tasks
    - 入参：name, type, queue_name, payload, priority, dedup_key, max_retries, retry_strategy
    - 返回：task_id, status
  - GET /api/v1/tasks/{id}
  - GET /api/v1/tasks?status=queued&queue=normal&page=1&size=20
  - POST /api/v1/tasks/{id}/cancel
- 运行记录
  - GET /api/v1/tasks/{id}/runs
  - GET /api/v1/runs/{run_id}
- Worker 管理
  - POST /api/v1/workers/register（queues, capacity）
  - POST /api/v1/workers/{id}/heartbeat
  - POST /api/v1/workers/{id}/drain
- 调度计划
  - POST /api/v1/schedules（task_template_id, cron_expr, timezone, enabled）
  - GET /api/v1/schedules
  - POST /api/v1/schedules/{id}/toggle
- 监控
  - GET /healthz
  - GET /metrics
- 安全：API Key 或 JWT；RBAC 授权（管理员/开发者/只读）。

### 示例：创建任务入参
```json
{
  "name": "generate_report",
  "type": "immediate",
  "queue_name": "normal",
  "priority": 5,
  "payload": {"report_id": 123},
  "dedup_key": "report_123_2025_11",
  "max_retries": 5,
  "retry_strategy": {"base": 5, "factor": 2, "max": 300}
}
```

## 9. 调度器（cron）
- 使用 robfig/cron v3 解析 cron 表达式，支持时区。
- 扫描策略：固定 tick（如 1s/10s），选择 enabled 且到期计划；生成 task_runs 并入队。
- 迟到与漏跑：记录 last_triggered_at；如服务重启后可按策略补偿漏跑。
- 失败保护：先持久化运行实例，后入队；入队失败重试与报警。

## 10. Worker 执行协议
- 拉取与租约：
  - 原子弹出：BRPOPLPUSH 或 Lua 保证移动到处理中队列（可选）；设置 `lease:{task_run_id}` TTL。
  - 执行过程中续租；到期未续租视为异常，可被其他 Worker 接管。
- 执行与上报：
  - 成功：task_runs=SUCCEEDED；更新 tasks 状态；删除租约。
  - 失败：计算 next_retry_at → 放入 delayed；task_runs=RETRYING/FAILED。
  - 达到最大重试：移入 DLQ；tasks=FAILED。
- 并发与资源：
  - Worker 支持本地并发；按队列权重与 capacity 控制消费速率。
- 幂等：
  - 使用 dedup_key 与历史结果缓存避免重复执行；必要时由业务实现幂等。

## 11. 部署与运维
- 容器与服务：
  - api（Gin）、scheduler（cron）、worker（多副本）、redis、postgres、nginx。
- Nginx：
  - 反向代理到 api；启用 TLS；基础限流与请求体大小限制。
- Supervisor：
  - Worker 进程保活；异常退出自动拉起；日志轮转。
- 环境变量：
  - DATABASE_URL、REDIS_URL、JWT_SECRET、QUEUE_NAMES、WORKER_CONCURRENCY、CRON_TICK_INTERVAL、MAX_RETRIES、RETRY_BACKOFF、TLS_CERT_PATH、TLS_KEY_PATH。

### docker-compose 草案（示意）
```yaml
version: '3.8'
services:
  api:
    image: your-org/distributed-tasks-api:latest
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/tasks?sslmode=disable
      - REDIS_URL=redis://redis:6379/0
      - JWT_SECRET=changeme
    depends_on: [postgres, redis]
  scheduler:
    image: your-org/distributed-tasks-scheduler:latest
    environment:
      - DATABASE_URL=postgres://user:pass@postgres:5432/tasks?sslmode=disable
      - REDIS_URL=redis://redis:6379/0
      - CRON_TICK_INTERVAL=1s
    depends_on: [postgres, redis]
  worker:
    image: your-org/distributed-tasks-worker:latest
    environment:
      - REDIS_URL=redis://redis:6379/0
      - DATABASE_URL=postgres://user:pass@postgres:5432/tasks?sslmode=disable
      - QUEUE_NAMES=high,normal,low
      - WORKER_CONCURRENCY=8
    depends_on: [postgres, redis]
  redis:
    image: redis:7
    command: ["redis-server", "--appendonly", "yes"]
  postgres:
    image: postgres:16
    environment:
      - POSTGRES_DB=tasks
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=pass
  nginx:
    image: nginx:stable
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf:ro
    depends_on: [api]
```

## 12. 可靠性与一致性
- 事务：任务创建与运行实例生成使用数据库事务保障原子性。
- 入队与状态：入队成功后写回状态；入队失败回滚或补偿流水。
- 去重：dedup_key 唯一约束；PENDING/QUEUED 请求返回已有任务。
- 重试与退避：指数退避（base、factor、max）；区分可重试与不可重试错误。
- DLQ：定期扫描与可视化管理；人工重放或删除。

## 13. 性能与容量规划
- 指标：QPS、队列长度、任务执行延迟、成功率、重试次数、Worker 并发利用率。
- 缓存：热点状态查询使用 Redis 缓存（短 TTL），权威写入以 DB 为准。
- 队列分层：高优先级独立队列；按业务线划分命名空间；流控与背压策略。

## 14. 安全与治理
- 身份认证：JWT 或 API Key；RBAC 模型（路由级）。
- 输入校验与限流：Gin 中间件统一参数校验、速率限制与请求体限制。
- 审计：任务创建/修改/取消/重放的审计日志；关键操作留痕。
- 数据保护：敏感信息加密或不落盘；全站 TLS。

## 15. 可观测性与告警
- 日志：结构化 JSON 日志（trace_id、task_id、run_id）。
- 追踪：可选 OpenTelemetry（OTLP），串联 API→Scheduler→Worker 链路。
- 告警：队列阻塞、失败率升高、心跳异常、DLQ 增长等阈值。

## 16. 测试策略
- 单元测试：任务状态机、重试策略、cron 触发计算。
- 集成测试：Redis 弹出/回填原子性、租约续期、并发执行。
- 端到端测试：API→Scheduler→Worker 全链路；故障与重试场景。
- 压测：不同并发与队列长度下的延迟与吞吐；资源消耗指标。

## 17. 迭代路线
- MVP：即时任务、单队列、基本重试与状态查询、单节点部署。
- v1：多队列优先级、定时任务、DLQ、心跳与租约、多副本。
- v2：RBAC、安全审计、指标与告警、灰度与滚更、弹性扩容。
- v3：跨地域、多租户、任务编排（DAG）。

## 18. 风险评估与对策
- Redis 阻塞或数据风险：开启 AOF，监控队列长度与延迟，DLQ 兜底。
- 任务重复执行：租约与幂等校验、结果缓存去重、Worker 接管策略。
- 调度漏跑：last_triggered_at 补偿、重启回放策略与报警。
- 热点队列拥塞：队列分层与权重消费、限流与背压、优先级降级。
- Worker 崩溃：Supervisor 保活、租约过期接管、失败告警与自动重试。

## 19. 术语与约定
- Task：任务定义（可即时或模板化）。
- TaskRun：一次具体运行实例，包含 attempt 次数。
- Lease：任务执行权租约（Redis key，TTL）。
- DLQ：死信队列，需人工处理或自动重放。

---
如需将本文进一步细化为接口 OpenAPI 契约、完善 DDL 细节或提供生产可用的 Nginx/Supervisor 配置与 Helm Chart，请在下一步明确需求，我会继续补充落地内容。
